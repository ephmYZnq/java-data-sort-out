## JVM

### 1. JVM简介
> JVM(JavaVirtualMachine)Java虚拟机的简称，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。一般的高级语言如果要在不同的平台上运行，至少要编译成不同的目标代码，而引入JVM后，Java语言在不同平台上运行时不需要重新编译，因为JVM屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。

### 2. JVM内存结构
> Java源代码编译成JavaClass文件后通过类加载器ClassLoader加载到JVM中。
>￼<br>![Markdown](https://i.loli.net/2021/04/26/HcOV1aJdBLQgpry.png)
>> - 方法区：属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量以及即时编译器编译后的代码等数据。 
>> - 堆：主要是存放对象的实例和数组。内部会分配出多个线程私有的缓冲区(ThreadLocalAllocationBuffer,TLAB)。可以位于物理地址不连续的空间，但是逻辑上要连续。 
>> - 虚拟机栈：每个方法在执行时都会创建一个栈帧(StackFrame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行结束的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
>> - 程序计数器：分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成。
>> - 本地方法栈：本地方法栈不同于Java虚拟机栈，后者为虚拟机执行Java方法(也就是字节码)，而前者则为虚拟机使用的Native方法提供服务。当然，二者也都会出现StackOverflowError和OutOfMemoryError异常。
>> - 解释器：方法执行时每行代码由解释器逐行执行。
>> - JIT编译器：热点代码由JIT编译器即时编译。
>> - 垃圾回收：回收堆中资源。
>> - 本地方法接口：和操作系统打交道。

### 3. JVM内存模型
> Java内存模型简称JMM（JavaMemoryModel），它能屏蔽掉各种硬件和操作系统的内存访问差异，以此实现Java程序在各种平台下一致的内存访问效果，不必因为不同平台上的物理机的内存模型的差异，对各平台定制化开发。
> <br>![Markdown](https://i.loli.net/2021/04/26/aXZ7dUypj1NF2oW.png)
>> #### 堆：
>>> 对于大多数应用来说，Java堆（JavaHeap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。
>> #### 方法区：
>>> 方法区（MethodArea）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做非堆（Non-Heap），目的应该是与Java堆区分开。垃圾收集行为在这个区域是比较少出现的，其内存回收目标主要是针对常量池的回收和对类型的卸载。当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。
>> #### 虚拟机栈：
>>> 虚拟机栈（JavaVirtualMachineStacks）是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（StackFrame），它是方法运行时的基础数据结构，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
>> #### 本地方法栈：
>>> 本地方法栈（NativeMethodStack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务（SunHotSpot虚拟机直接就把本地方法栈和虚拟机栈合二为一）。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。
>>> 线程开始调用本地方法时，JVM暂时无法对其约束。而本地方法可以通过JNI(JavaNativeInterface)来访问虚拟机运行时的数据区，甚至可以调用寄存器，具有和JVM相同的能力和权限。当大量本地方法出现时，势必会削弱JVM对系统的控制力，因为它的出错信息都比较黑盒。如果出现内存不足的情况，本地方法栈还是会抛出NativeHeapOutOfMemory。
>> #### 程序计数器：
>>>程序计数器（ProgramCounterRegister）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。

### 4. 垃圾回收
> Java相比C/C++最显著的特点便是引入了自动垃圾回收(下文统一用GC指代自动垃圾回收)，它解决了C/C++最令人头疼的内存管理问题，让程序员专注于程序本身，不用关心内存回收这些恼人的问题。
> #### 4.1 垃圾识别机制
>> ##### 4.1.1 引用计数法
>>> 简单地说，就是对象被引用一次，在它的对象头上加一次引用次数，如果没有被引用（引用次数为0），则此对象可回收。但是缺点是无法解决对象之间相互循环引用的问题，如下图：虽然a，b都被置为null了，但是由于之前它们指向的对象互相指向了对方（引用计数都为1），所以无法回收，也正是由于无法解决循环引用的问题，所以现代虚拟机都不用引用计数法来判断对象是否应该被回收。
>>> <br>![Markdown](https://i.loli.net/2021/04/26/ournFxS8cMhf4tE.png)
>> ##### 4.1.2 可达性算法
>>> 通过一系列的称为"GCRoots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（ReferenceChain），当一个对象到GCRoots没有任何引用链相连时，则证明此对象是不可用的。此算法解决了上述循环引用的问题。
>>> <br>![Markdown](https://i.loli.net/2021/04/26/ekKbH8C17ardihT.png)
>>> <br>而图中a，b对象虽然是可回收的，但是会首先判断对象是否执行finalize方法，如果未执行，则会先执行finalize方法，我们可以在此方法里将当前对象与GCRoots关联，这样执行finalize方法之后，GC会再次判断对象是否可达，如果不可达，则会被回收，如果可达，则不回收。
>>> 这里finalize方法只会被执行一次，如果第一次执行finalize方法此对象变成了可达之后，确实不会回收。但如果对象再次被GC，则会忽略finalize方法，对象会被回收。
>>> 这里补充一下强引用、软引用、弱引用、虚引用。JDK1.2以前，一个对象只有被引用和没有被引用两种状态。后来，Java对引用的概念进行了扩充，将引用分为强引用（StrongReference）、软引用（SoftReference）、弱引用（WeakReference）、虚引用（PhantomReference）4种，这4种引用强度依次逐渐减弱。
>>>> 强引用：<br>指在程序代码之中普遍存在的，类似"Object obj = new Object()"这类的引用，垃圾收集器永远不会回收存活的强引用对象。<br>
     软引用：<br>有用但非必需的对象。在系统将要发生内存溢出异常之前 ，将会把这些对象列进回收范围之中进行第二次回收。<br>
     弱引用：<br>被弱引用关联的对象 只能生存到下一次垃圾收集发生之前 。当垃圾收集器工作时，无论内存是否足够，都会回收掉只被弱引用关联的对象。<br>
     虚引用：<br>虚引用是最弱的一种引用关系。无法通过虚引用来取得一个对象实例 。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。<br>
> #### 4.2 垃圾回收算法
> 主要有四种算法：标记清除算法、标记整理算法、复制算法、分代收集算法。
>> ##### 4.2.1 标记清除算法
>>> 首先根据可达性算法标记出相应的可回收对象（图中黄色部分），然后对可回收的对象进行回收。
>>> <br>![Markdown](https://i.loli.net/2021/04/26/RnaJyOxTfz5vuU8.png)
>>> <br>缺点：<br>效率问题：标记和清除两个过程的效率都不高。
             <br>空间问题：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。
>> ##### 4.2.2 标记整理算法
>>> 前面两步和标记清除法一样，不同的是它在标记清除法的基础上添加了一个整理的过程，即将所有的存活对象都往一端移动，紧邻排列（如图示），再清理掉另一端的所有区域，这样的话就解决了内存碎片的问题。
>>> <br>![Markdown](https://i.loli.net/2021/04/26/SAOni1935LIjXf4.png)
>>> <br>缺点：每进一次垃圾清除都要频繁地移动存活的对象，效率很低。

